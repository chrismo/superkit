// cannot get above EB with uint64 - sorry "ZB" & "YB" and beyond...
const k_bytes_units=["B", "KB", "MB", "GB", "TB", "PB", "EB"]
const k_bytes_divisor=1024

func _k_bytes_unit_index(value): (
  uint64(floor(log(value) / log(k_bytes_divisor)))
)

func _kformat_nonzero_bytes(value): (
  f"{uint64(value / pow(k_bytes_divisor, _k_bytes_unit_index(value)))} {k_bytes_units[_k_bytes_unit_index(value)]}"
)

// {skdoc:{desc:"Returns the size in bytes in human readable format.",
//         args:[{value:"Must be castable to uint64"}],
//         examples:[{i:"kformat_bytes(1048576)",o:'"1 MB"'}] } }
func kformat_bytes(value): (
  (value == 0) ? "0 B" : _kformat_nonzero_bytes(value)
)
// the built-in `fields` function is similar, but puts each field into its own
// nested array, though it also handles nested keys. This keys operator here
// attempts to emulate jq's keys, which does not go deep but only lists the
// top-level ones.

op kkeys(): (
  // ... with sorted keys:
  // over this => (this.key[0]) | sort | collect(this)

  // ... in order:
  over this => (this.key[0]) | collect(this)
)

op kmerge_records(): (
  string(this)
  | replace(this, "},{",",")
  | parse_zson(this[1:-1])
)

// # this sort of approach suffers from an illegal left-hand assignment:
// ‚ùØ zq '[{a:1},{b:{c:333}}] | (over this with obj={} | flatten(this) | obj[key[0]]:=value )'

// # this was a better step from Phil, but doesn't work on nested records
// over this
// | over flatten(this)
// | collect_map(|{key[0]:value}|)
// | yield parse_zson(replace(string(this), "|", ""))'


func kversion(): (
  "0.1.0"
)
