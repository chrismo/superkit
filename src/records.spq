-- sk_include array.spq

-- the built-in `fields` function is similar, but puts each field into its own
-- nested array, though it also handles nested keys. This keys operator here
-- attempts to emulate jq's keys, which does not go deep but only lists the
-- top-level ones.

fn skdoc_keys(): (
  cast(
    {name:"sk_keys",
     type:"op",
     desc:"Returns the keys of the top-level fields in a record. This does not go deep into nested records.",
     args:[],
     examples:[{i:"{a:1,b:{c:333}} | sk_keys",o:"['a','b']"},
               {i:"{x:10,y:20,z:30} | sk_keys",o:"['x','y','z']"}] }, <skdoc>)
)

op sk_keys: (
  fields(this) | unnest this | values this[0] | uniq | collect(this)
)

fn skdoc_merge_records(): (
  cast(
    {name:"sk_merge_records",
     type:"op",
     desc:"Merges an array of records into a single record by combining the fields. If there are duplicate keys, the last one wins.",
     args:[],
     examples:[{i:"[{a:1},{b:{c:333}}] | sk_merge_records",o:"{a:1,b:{c:333}}"}] }, <skdoc>)
)

op sk_merge_records: (
  this::string
  | replace(this, "},{",",")
  | parse_sup(this[1:-1])
)

-- # this sort of approach suffers from an illegal left-hand assignment:
-- ‚ùØ zq '[{a:1},{b:{c:333}}] | (over this with obj={} | flatten(this) | obj[key[0]]:=value )'

-- # this was a better step from Phil, but doesn't work on nested records
-- over this
-- | over flatten(this)
-- | collect_map(|{key[0]:value}|)
-- | values parse_sup(replace(this::string, "|", ""))'

fn skdoc_add_ids(): (
  cast(
    {name:"sk_add_ids",
     type:"op",
     desc:"Prepends an incrementing id field to each record. Always returns an array.",
     args:[],
     examples:[{i:"[{a:3},{b:4}] | sk_add_ids",o:"[{id:1,a:3},{id:2,b:4}]"}] }, <skdoc>)
)

op sk_add_ids: (
  sk_in_array(this)
  | unnest this
  | count
  | values {id:count,...that}
  | collect(this)
)
