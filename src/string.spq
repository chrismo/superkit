-- sk_include integer.spq
-- sk_include integer.spq -- to test duplicate includes

op skdoc_slice: (
  cast(
    {name:"sk_slice",
     type:"func",
     desc:"Returns a slice of the string passed in, even if indexes are out of range.",
     args:[{name:"s",desc:"The string to slice."},
           {name:"start",desc:"Starting index, zero-based, inclusive."},
           {name:"end",desc:"Ending index, exclusive."}],
     examples:[{i:"sk_slice('howdy')",o:"'Howdy'"}] }, <skdoc>)
)

-- This isn't necessary with zq, but during early releases of super, the
-- behavior of slice was changed to return an error if the indexes are out of
-- range. There was discussion of possibly returning to the old behavior.
fn sk_slice(s, start, end): (
  s[sk_clamp(start, -len(s), len(s)):sk_clamp(end, -len(s), len(s))]
)

op skdoc_capitalize: (
  cast(
    {name:"sk_capitalize",
     type:"func",
     desc:"Upper the first character of the string, lower the remaining string.",
     args:[{name:"s",desc:"The string to capitalize."}],
     examples:[{i:"sk_capitalize('hoWDy')",o:"'Howdy'"}] }, <skdoc>)
)

fn sk_capitalize(s): (
  f"{upper(sk_slice(s, 0, 1))}{lower(sk_slice(s,1,len(s)))}"
)

op skdoc_titleize: (
  cast(
    {name:"sk_titleize",
     type:"func",
     desc:"Splits string by space and capitalizes each word.",
     args:[{name:"s",desc:"The string to titleize"}],
     examples:[{i:"sk_titleize('once uPON A TIME')",o:"'Once Upon A Time'"}] }, <skdoc>)
)

fn sk_titleize(s): (
  -- this could be smarter, ignoring insignificant words
  -- and such, but that will be a lot more complex.
  [unnest split(s, " ") | values sk_capitalize(this)] | join(this, " ")
)

fn skdoc_pad_left(): (
  cast(
    {name:"sk_pad_left",
     type:"func",
     desc:"Inserts pad_char to the left of the string until it reaches target_length.",
     args:[{name:"s",desc:"The string to pad"},
           {name:"pad_char",desc:"The character to pad with"},
           {name:"target_length",desc:"The target length of the string"}],
     examples:[{i:"values sk_pad_left('abc', ' ', 5)",o:"'  abc'"}] }, <skdoc>)
)

fn sk_pad_left(s, pad_char, target_length): (
  len(s) < target_length ? sk_pad_left(f'{pad_char}{s}', pad_char, target_length) : s
)

fn skdoc_pad_right(): (
  cast(
    {name:"sk_pad_right",
     type:"func",
     desc:"Inserts pad_char to the right of the string until it reaches target_length.",
     args:[{name:"s",desc:"The string to pad"},
           {name:"pad_char",desc:"The character to pad with"},
           {name:"target_length",desc:"The target length of the string"}],
     examples:[{i:"values sk_pad_right('abc', ' ', 5)",o:"'abc  '"}] }, <skdoc>)
)

fn sk_pad_right(s, pad_char, target_length): (
  len(s) < target_length ? sk_pad_right(f'{s}{pad_char}', pad_char, target_length) : s
)

-- TODO: skdoc_urldecode

-- URL Decoder for SuperDB
-- Usage: super -I urldecode.spq -s -c 'values urldecode(this)' - <<< '"%2Ftavern%20test"'
-- Or inline the definitions in your query

-- Helper operator to decode a single segment after splitting on %
-- If the segment starts with valid 2-char hex, converts it to the character
-- Otherwise returns the segment as-is
op sk_decode_seg s: (
  len(s) == 0
    ? s
    : (is_error(hex(s[1:3]))
        ? s
        : hex(s[1:3])::string + s[3:])
)

-- Main URL decoder operator
-- Splits on %, decodes each hex-encoded segment, and joins back together
op sk_urldecode url: (
  split(url, "%")
    | unnest this
    | decode_seg this
    | collect(this)
    | join(this, "")
)
