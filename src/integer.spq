-- TODO: this doesn't cause any problems yet because we're not recursively
-- scanning sk_include files for _their_ sk_includes.

-- sk_include string.spq -- test circular dependencies

op skdoc_clamp: (
  cast(
    {name:"sk_clamp",
     type:"func",
     desc:"Clamps a value between min and max.",
     args:[{name:"i",desc:"The value to clamp."},
           {name:"min",desc:"The minimum value."},
           {name:"max",desc:"The maximum value."}],
     examples:[{i:"sk_clamp(1, 2, 3)",o:"2"},
               {i:"sk_clamp(4, 2, 3)",o:"3"},
               {i:"sk_clamp(2, 2, 3)",o:"2"}]}, <skdoc>)
)

fn sk_clamp(i, min, max): (
    i < min ? min : i > max ? max : i
)

fn skdoc_min(): (
  cast(
    {name:"sk_min",
     type:"func",
     desc:"Returns the minimum of two values.",
     args:[{name:"a",desc:"The first value."},
           {name:"b",desc:"The second value."}],
     examples:[{i:"sk_min(1, 2)",o:"1"},
               {i:"sk_min(3, 2)",o:"2"},
               {i:"sk_min(2, 2)",o:"2"}]}, <skdoc>)
)

fn sk_min(a, b): (
  a < b ? a : b
)

fn skdoc_max(): (
  cast(
    {name:"sk_max",
     type:"func",
     desc:"Returns the maximum of two values.",
     args:[{name:"a",desc:"The first value."},
           {name:"b",desc:"The second value."}],
     examples:[{i:"sk_max(1, 2)",o:"2"},
               {i:"sk_max(3, 2)",o:"3"},
               {i:"sk_max(2, 2)",o:"2"}]}, <skdoc>)
)

fn sk_max(a, b): (
  a > b ? a : b
)
